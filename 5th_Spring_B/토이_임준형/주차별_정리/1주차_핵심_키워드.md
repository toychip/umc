# 1주차 핵심 키워드

## TCP
- Transport Layer에 위치하며 포트 번호를 이용해 주소를 특정함.
- 신뢰성을 보장하는 연결 지향 프로토콜.
- 연결 시작 시 3-way, 종료 시 4-way handshake를 사용.
- 순서를 보장하지만 UDP와 비교해 상대적으로 속도가 느림.

## UDP
- Transport Layer에 위치하며 포트 번호를 이용해 주소를 특정함.
- 신뢰성을 보장하지 않는 비 연결 지향 프로토콜.
- Handshake 과정이 없음.
- 순서를 보장하지 않으며 TCP에 비해 상대적으로 속도가 빠름.

## 시스템 콜
- 응용 프로그램의 요청에 따라 커널에 접근하는 인터페이스.
- 운영체제는 자신의 커널 영역에서 해당 index가 가리키는 주소에 저장된 루틴을 수행.
- 시스템 콜이 필요한 이유는 유저 레벨의 프로그램이 유저 레벨의 함수만으로 구현하기 어렵기 때문.
- 시스템 콜의 유형에는 프로세스 컨트롤, 파일 매니지먼트, 디바이스 매니지먼트, 정보 관리, 통신, 보안 등이 있음.
- PC 레지스터가 사용자 프로그램이면 유저모드, 운영체제이면 커널모드.

## 하드웨어 인터럽트
- CPU에게 어떤 이벤트가 발생했음을 알리는 신호.
- 이를 통해 CPU는 현재 실행 중인 작업을 일시 중단하고 인터럽트를 처리함.

## 리눅스의 파일과 파일 디스크립터
- 리눅스에서는 모든 것을 파일로 취급.
- 파일 디스크립터는 파일에 접근하기 위한 정수형 핸들로, 시스템 콜을 통해 파일을 읽거나 쓸 때 사용함.

## socket() 시스템 콜
- 소켓을 만드는 시스템 콜.
- `socket(domain, type, protocol)`로 구성되어 있으며, IPV4/IPV6, TCP/UDP 중 선택하는 메서드.
- `domain`: IPV4, IPV6 선택, `type`: stream, datagram 선택, `protocol`: 0(선택권 넘김), 6(UDP), 17(TCP) 중 선택.
- 반환 값은 파일 디스크립터.

## bind() 시스템 콜
- 생성한 소켓에 실제 IP 주소와 PORT 번호를 부여하는 메서드.
- `bind(sockfd, sockaddr, socklen_t)`로 구성됨.
- `sockfd`: 바인딩할 소켓의 파일 디스크립터, `sockaddr`: IP 주소 + PORT 번호, `socklen_t`: 구조체의 크기.
- 클라이언트는 통신 시 포트 번호가 자동으로 부여되므로 이 메서드는 서버만 사용함.

## listen() 시스템 콜
- TCP에서만 사용.
- `listen(sockfd, backlog)`로 구성됨.
- `sockfd`: `socket()` 메서드의 반환 값, `backlog`: 클라이언트의 연결 요청을 받아들이는 최대 크기.

## accept() 시스템 콜
- `backlog queue`에서 `SYN`을 보내와 대기 중인 요청을 큐로 하나씩 연결에 대한 수집을 함.
- `accept(sockfd, sockaddr, socklen_t)`로 구성됨.
- `sockfd`: 큐의 요청을 받아들이기 위한 소켓의 파일 디스크립터, `sockaddr`: 클라이언트 주소 정보, `socklen_t`: 구조체의 메모리 크기.
- `SYN` 요청을 보낸 클라이언트가 있어 backlog queue에 있었고, 해당 클라이언트의 요청에 대한 응답을 위해 새로운 소켓을 생성함.

## 멀티 프로세스
- `fork()`를 통해 자신과 똑같은 자식 프로세스를 생성.
- `fork()`를 호출한 프로세스는 `pid`에 자식 프로세스의 프로세스 ID 값을 받음, 자식은 0을 받음.
- 부모 프로세스는 연결 요청을 받아주고 자식 프로세스에게 나머지 일을 맡김.

## 병렬 처리
- 부모 프로세스가 자식 프로세스에게 나머지 일을 맡김으로써, 서버는 연결을 받는 부분과 응답을 주는 부분을 병렬적으로 처리함.
