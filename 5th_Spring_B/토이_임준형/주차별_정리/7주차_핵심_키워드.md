# 영속성 컨텍스트

## 영속성 컨텍스트란?

`엔티티를 영구 저장하는 환경`이다. 눈에 보이지 않고 논리적인 개념으로, EntityManager를 통해 영속성 컨텍스트에 접근할 수 있다.

🛠 **EntityManager가 생성되는 과정**
1. DB 하나당 하나의 EntityManagerFactory 인스턴스가 생성된다.
2. EntityManagerFactory는 클라이언트의 요청이 올 때마다 EntityManager를 생성한다.
3. EntityManager는 내부적으로 DB 커넥션 풀을 사용한다.

☝ **DB 커넥션 풀의 생명주기는 어떻게 될까?**

JPA를 의존하는 프로젝트를 처음 실행할 경우 아래와 같은 오류가 ‘항상’ 발생하는 것을 볼 수 있다.

**왜그럴까?**

**OSIV 설정** 때문인데, 영속성 컨텍스트가 Repository부터 Service까지만 살아있기에, 커넥션풀이 말라버려 죽을 수 있다는 경고이다.

만약, 해당 Api가 많은 트래픽을 받는 API라면 필수로 이를 해결해야한다.

```yaml
jpa:
  open-in-view: false # 해당 설정으로 이를 방지 가능
  ```

컨트롤러에서 호출한 다른 api를 호출 중에 오래걸린다면? 거기서 오래걸려 말라 죽어버릴 것이다. 그렇기 때문에 Service에서 이를 모두 해결하고, 컨트롤러에 전달하는 것이 이상적이다.

영속성 컨텍스트 내부에 있는 1차캐시에는 **엔티티로 생성된 객체**와, **엔티티**, 그리고 **가장 최초 상태를 복사한 스냅샷**이 존재한다.

# 양방향 매핑

비교적 편한 설명을 위해 예제를 사용한다.

🔥 **객체의 연관관계**

**객체 연관관계는 2개**이다.

Team -> Member 연관관계 1개 (단방향)

Member -> Team 연관관계 1개 (단방향)

객체의 양방향 관계는 **사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개**이다.

객체를 양방향으로 참조하려면 **단방향 연관관계를 2개** 만들어야 한다.

🔥 **테이블의 연관관계**

**테이블에서는 연관관계는 1개**이다.

테이블은 외래 키 하나로 두 테이블의 연관관계를 **관리**한다.

TEAM_ID FK를 통해서 양쪽에서 조회가 다 가능하다.

MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계를 가진다. (양쪽으로 조인할 수 있다)

테이블에 있어 수정이 필요하면 TEAM을 수정하면 된다.

하지만 객체에 있어서는 Member의 Team이 업데이트 됐을 때 **table의 TEAM_ID를 수정해야 할지**, Team의 List members가 업데이트 됐을 때 **table의 TEAM_ID를** 수정해야 할지 혼란스럽다.

둘 중 **하나로** 외래 키를 관리해야 한다.

# N + 1 문제

### N + 1 문제란 조회하려는 쿼리 1개 때문에 N개가 추가적으로 생기는 문제를 말한다.

```java
fetch = FetchType.EAGER
```

위와 같이 사용할 수 없는 이유는, 연관관계가 걸린 모든 객체를 한 번에 조회하기 때문에 사용하면 안 된다.

성능문제
쿼리를 예측할 수 없음
그렇기 때문에, 우리는 지연로딩을 사용해야 한다.

```java
fetch = FetchType.LAZY
```

이렇게 사용시, 한 객체를 갖고 올 때, 연관관계에 걸린 객체를 가짜의 객체 즉 Proxy 객체로 가져온다.

하지만 이렇게 될 경우 예를 들어 한 Team에 2명의 Member가 있다고 가정해보자.

team이 1개이고 member가 2명이라면 team을 조회하는 쿼리 1개, 팀에 해당하는 멤버 2명을 갖고오는 쿼리 2개, 총 3개가 나간다. 우리는 Team에 있는 모든 멤버를 조회하는 쿼리 1개가 필요한 것인데, member가 n명 즉, 여기선 2명이므로 1 + N(2) 문제가 발생한 것이다. 이를 해결하기 위해 team에 있는 멤버를 조회할 때 jpql에서 fetch join으로 where in(?, ?, ?, ?) 을 사용하여 한 번에 갖고오도록하면 N + 1 문제를 해결할 수 있다.

하지만 이렇게 해결한다 해도 페이징을 하고 싶다면?

fetch join을 사용하면 xToOne일 때는 페이징에 문제가 없다.

하지만 xToMany일 때, 컬렉션일 때는 이를 해결할 수가 없다.

- 데이터가 뻥튀기 된다. 1개와 2개의 각각 다른 테이블일 때 이를 조인하면 총 2개의 결과를 보여준다.
- 하지만 우리는 1개의 결과를 알고 싶은데 2개가 나오게 되기 때문이다.

이를 해결하기 위해, 1:n, 즉 컬렉션인 경우면서 페이징을 필수로 처리해야 할 때 지연로딩 그대로 가져가되, BatchSize 혹은 아래와 같은 설정으로 뭉텅이로 한 번에 갖고오도록 한다면, 이 모두를 해결할 수 있다.

``` yaml
jpa:
    properties:
    		default_batch_fetch_size: 100
```